# SQL 활용

## 1. 표준 조인

#### 1. STANDARD SQL 개요

- 가. 일반 집합 연산자

  ![image-20200526021243284](images/image-20200526021243284.png) 

  1. UNION

     SQL - UNION 기능

     수학적 합집합을 제공하고 공통 교집합의 중복을 없애기 위한 사전 작업으로 시스템의 부하를 줄여주는 정렬 작업이 발생

     이후 `UNION ALL` 기능 추가 - 특별한 요구 사항이 없다면 공통집합을 중복해서 그대로 보여주기 때문에 정렬 작업이 일어나지 않는 장점

     만약 `UNION`과 `UNION ALL`의 출력 결과가 같다면, 응답 속도 향상이나 자원 효율화 측면에서 데이터 정렬 작업이  발생하지 않는 `UNION ALL`을 사용하는 것을 권고

  2. INTERSECTION

     SQL - INTERSECTION 기능

     수학의 교집합으로 두 집합의 공통 집합 추출

  3. DIFFERENCE

     SQL - EXCEPT(ORACLE - MINUS) 기능

     수학적 차집합

     첫 번째 집합 - 두 번째 집합

     대다수 벤더는 `EXCEPT`를 ORACLE은 `MINUS`용어 사용 (SQL 표준에는 `EXCEPT`로 표시되어 있으며, 벤더에서 SQL 표준 기능을 구현할 때 다른 용어를 사용하는 것은 현실적으로 허용되고 있음)

   4. PRODUCT

      SQL - CROSS JOIN 기능

      CROSS PRODUCT라고 불리는 곱집합

      JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합

      양쪽 집합의 `M*N` 건의 데이터 조합이 발생

      CASTESIAN PRODUCT라고도 표현

- 나. 순수 관계 연산자

  ![image-20200526021838007](images/image-20200526021838007.png) 

  순수 관계 연산자는 관계형 DB를 구현하기 위해 새로 만들어진 연산자

  5. SELECT 연산

     SQL - WHERE 절로 구현

  6. PROJECT 연산

     SQL - SELECT 절로 구현

  7. (NATURAL) JOIN

     SQL - 다양한 JOIN 기능으로 구현

     INNER JOIN, NATURAL JOIN, OUTER JOIN, USING 조건절, ON 조건절 등

  8. DIVDE

     SQL - 현재 사용되지 않음

     그림에서 왼쪽 집합을 'XZ'로 나눴을 때, 'XZ'를 모두 가지고 있는 'A'가 답이 되는 기능

- 관계형 DB의 경우 요구사항 분석, 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링 단계를 거치게 되는데, 이 단계에서 엔티티 확정 및 정규화 과정, 그리고 M:N 관계를 분해하는 절차를 거치게 됨

  특히 정규화 과정의 경우 데이터 정합성과 데이터 저장 공간의 절약을 위해 엔티티를 최대한 분리하는 과정으로, 일반적으로 3차 정규형이나 BCNF 까지 진행하게 됨

  이런 정규화를 거치면 하나의 주제에 관련 있는 엔티티가 여러 개로 나누어지게 되고, 이 엔티티들이 주로 테이블이 되는데 이렇게 흩어진 데이터를 연결해 원하는 데이터로 가져오는 작업이 바로 JOIN

  관계형 DB에 있어 JOIN은 SQL의 가장 중요한 기능



#### 2. FROM절 JOIN 형태

- ANSI/ISO SQL에서 표시하는 FROM절의 JOIN 형태

  ```
  - INNER JOIN - NATURAL JOIN - USING 조건절 - ON 조건절- CROSS JOIN - OUTER JOIN
  ```

  ANSI/ISO SQL에서 규정한 JOIN 문법은 WHERE절을 사용하던 기존 JOIN 방식과 차이가 있음

  사용자는 기존 WHERE 절의 검색 조건과 테이블 간의 JOIN 조건을 구분 없이 사용하던 방식을 그대로 사용할 수 있으면서, 추가된 선택 기능으로 테이블 간의 JOIN 조건을 FROM절에서 명시적으로 정의할 수 있게 됨

  `INNER JOIN`: WHERE절에서부터 사용하던 JOIN의 DEFAULT 옵션

  ​                        JOIN 조건에서 동일한 값이 있는 행만 반환

  ​						DEFAULT 옵션이므로 생략 가능 BUT `CROSS JOIN` `OUTER JOIN`과 같이 사용 불가

  `NATURAL JOIN`: `INNER JOIN`의 하위 개념

  ​							두 테이블 간 동일한 이름을 갖는 모든 칼럼에 대해 EQUI(=) JOIN 수행

  ​							`NATURAL INNER JOIN`이라고 표시 가능

  `ON 조건절`: 새로운 SQL JOIN 문장 중에서 **가장 중요하게 기억해야 하는 문장**

  ​					`NATURAL JOIN`처럼 JOIN 조건이 숨어 있지 않고, 명시적으로 JOIN 조건 구분 가능

  ​					`NATURAL JOIN`이나 `USING` 조건절처럼 칼럼명이 똑같아야 된다는 제약 없이 칼럼명이 달라도

  ​					JOIN 조건으로 사용 가능

  ​					다만, FROM 절에 테이블이 많이 사용될 경우 다소 복잡해보여 가독성이 떨어지는 단점

  ​					이런 측면에서 SQL SERVER가 `ON 조건절`만 지원하고 `NATURAL JOIN` `USING`조건절을

  ​					지원하지 않는 것으로 보임



#### 3. INNER JOIN

- `OUTER JOIN`과 대비해 내부 JOIN이라고 하며 JOIN 조건에서 동일한 값이 있는 행만 반환

- `INNER JOIN 표시`: WHERE 절에서 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시이므로 `USING 조건절`이나 `ON 조건절`을 필수적으로 사용해야 함

- 예제 - 사원 번호, 사원 이름, 소속부서 코드, 소속부서 이름 출력

  <WHERE절 JOIN 조건>

  ```SQL
  SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
  FROM EMP, DEPT
  WHERE EMP.DEPTNO = DEPT.DEPTNO;
  ```

  < FROM절 JOIN 조건>

  ```SQL
  SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
  FROM EMP INNER JOIN DEPT
  ON EMP.DEPTNO = DEPT.DEPTNO;
  ```

  < INNER JOIN은 DEFAULT로 아래와 같이 생략 가능>

  ```SQL
  SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
  FROM EMP JOIN DEPT
  ON EMP.DEPTNO= DEPT.DEPTNO;
  ```



#### 4. NATURAL JOIN

- 두 테이블 간의 동일한 이름을 갖는 모든 칼럼들에 대해 `EQUI JOIN`을 수행

  `NATURAL JOIN`이 명시되면 추가로 `USING 조건절`, `ON 조건절`, `WHERE 절`에서 JOIN 조건을 정의할 수 없음

- 예제 - 사원번호, 사원 이름, 소속부서 코드, 소속부서 이름 출력

  ```SQL
  SELECT DEPTNO, EMPNO, ENAME, DNAME
  FROM EMP NATURAL JOIN DEPT;
  ```

  위 SQL은 별도의 JOIN 칼럼을 지정하지 않았지만 두 개의 테이블에서 `DPETNO`라는 공통된 칼럼을 자동으로 인식해 JOIN을 처리

  JOIN에 사용된 칼럼들은 같은 데이터 유형이어야 하며, ALIAS나 테이블 명과 같은 접두사를 붙일 수 없음

  ```SQL
  SELECT EMP.DEPTNO, EMPNO, ENMAE, DNAME
  FROM EMP NATURAL JOIN DPET; // ERROR: NATURAL JOIN에 사용된 열은 식별자를 가질 수 없음
  ```

- 예제 - `*` 와일드 카드처럼 별도의 칼럼 순서를 지정하지 않으면 NATURAL JOIN의 기준이 되는 칼럼들이 다른 칼럼보다 먼저 출력 (DEPTNO가 첫 번째 칼럼)

  이 때, JOIN에 사용된 같은 이름의 칼럼을 하나로 처리

  ```SQL
  SELECT * FROM EMP NATURAL JOIN DEPT;
  ```

  ```
  DEPTNO EMPNO ENAME JOB MGR HIREDATE SAL COMM DNAME LOC 
  ----- ----- ------------- --- -------- ---- ---- --------- ------ 
  20 7369 SMITH CLERK 7902 1980-12-17 800 RESEARCH DALLAS 
  30 7499 ALLEN SALESMAN 7698 1981-02-20 1600 300 SALES CHICAGO 
  30 7521 WARD SALESMAN 7698 1981-02-22 1250 500 SALES CHICAGO 
  20 7566 JONES MANAGER 7839 1981-04-02 2975 RESEARCH DALLAS 
  30 7654 MARTIN SALESMAN 7698 1981-09-28 1250 1400 SALES CHICAGO 
  30 7698 BLAKE MANAGER 7839 1981-05-01 2850 SALES CHICAGO 
  10 7782 CLARK MANAGER 7839 1981-06-09 2450 ACCOUNTING NEW YORK 
  20 7788 SCOTT ANALYST 7566 1987-07-13 3000 RESEARCH DALLAS 
  10 7839 KING PRESIDENT 1981-11-17 5000 ACCOUNTING NEW YORK 
  30 7844 TURNER SALESMAN 7698 1981-09-08 1500 SALES CHICAGO 
  20 7876 ADAMS CLERK 7788 1987-07-13 1100 RESEARCH DALLAS 
  30 7900 JAMES CLERK 7698 1981-12-03 950 0 SALES CHICAGO 
  20 7902 FORD ANALYST 7566 1981-12-03 3000 RESEARCH DALLAS 
  10 7934 MILLER CLERK 7782 1982-01-23 1300 ACCOUNTING NEW YORK
  ```

- 예제 - 반면 `INNER JOIN`의 경우 첫 번째 테이블, 두 번째 테이블의 칼럼 순서대로 데이터가 출력됨

  이때 `NATURAL JOIN`은 JOIN에 사용된 같은 이름의 칼럼을 하나로 처리하지만,

  **INNTTER JOIN은 별개의 칼럼으로 표시 **

  ```SQL
  SELECT *
  FROM EMP INNER JOIN DEPT
  ON EMP.DEPTNO = DEPT.DEPTNO;
  ```

  ```
  EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO DEPTNO DNAME LOC 
  ---- ----- ------ --- ------- --- ---- ----- ----- -------- ----- 
  7369 SMITH CLERK 7902 1980-12-17 800 20 20 RESEARCH DALLAS 
  7499 ALLEN SALESMAN 7698 1981-02-20 1600 300 30 30 SALES CHICAGO 
  7521 WARD SALESMAN 7698 1981-02-22 1250 500 30 30 SALES CHICAGO 
  7566 JONES MANAGER 7839 1981-04-02 2975 20 20 RESEARCH DALLAS 
  7654 MARTIN SALESMAN 7698 1981-09-28 1250 1400 30 30 SALES CHICAGO 
  7698 BLAKE MANAGER 7839 1981-05-01 2850 30 30 SALES CHICAGO 
  7782 CLARK MANAGER 7839 1981-06-09 2450 10 10 ACCOUNTING NEW YORK 
  7788 SCOTT ANALYST 7566 1987-07-13 3000 20 20 RESEARCH DALLAS 
  7839 KING PRESIDENT 1981-11-17 5000 10 10 ACCOUNTING NEW YORK 
  7844 TURNER SALESMAN 7698 1981-09-08 1500 0 30 30 SALES CHICAGO 
  7876 ADAMS CLERK 7788 1987-07-13 1100 20 20 RESEARCH DALLAS 
  7900 JAMES CLERK 7698 1981-12-03 950 30 30 SALES CHICAGO 
  7902 FORD ANALYST 7566 1981-12-03 3000 20 20 RESEARCH DALLAS 
  7934 MILLER CLERK 7782 1982-01-23 1300 10 10 ACCOUNTING NEW YORK
  ```

- 예제 - `NATURAL JOIN`과 `INNER JOIN`의 차이를 자세히 설명하기 위해 DEPT_TEMP 테이블을 임시로 만듦

  ```
  [ORACLE] CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
  [SQL] SELECT * INTO DEPT_TEMP FROM DEPT;
  
  UPDATE DEPT
  ```

  

